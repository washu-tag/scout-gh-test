name: Post-Commit Tasks

on:
  pull_request:
    types: [opened, reopened]
  push:
    branches:
      - main

env:
  JAVA_DIST: 'zulu'
  JAVA_VERSION: '21'
  REGISTRY: ghcr.io

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4.2.1
      - name: Start a local k8s cluster
        uses: jupyterhub/action-k3s-helm@v4
        with:
          k3s-channel: latest
          traefik-enabled: false
      - name: Deploy helm chart to kubernetes
        shell: bash
        run: |
          helm repo add temporal https://go.temporal.io/helm-charts
          helm repo update temporal
          kubectl create ns temporal
          helm upgrade --install -n temporal temporal temporal/temporal --set-json web.additionalEnv='[{"name": "TEMPORAL_CSRF_COOKIE_INSECURE", "value": "true"}]' --set prometheus.enabled=false --set grafana.enabled=false --set server.replicaCount=1 --set cassandra.config.cluster_size=1 --set elasticsearch.replicas=1
      - name: Build images
        shell: bash
        run: |
          docker build -t local/temporal-java:latest orchestration/temporal-java/
          docker build -t local/temporal-python:latest orchestration/temporal-python/
      - name: Launch Temporal Workers
        shell: bash
        run: |
          kubectl create ns orchestration-workers
          kubectl -n orchestration-workers create secret generic s3-secret --from-literal=AWS_ACCESS_KEY_ID=admin --from-literal=AWS_SECRET_ACCESS_KEY=password
          kubectl -n orchestration-workers create configmap s3-env --from-literal=AWS_ENDPOINT_URL=http://minio.minio:9000 --from-literal=AWS_ALLOW_HTTP=true --from-literal=AWS_REGION=us-east-1
          helm upgrade --install -n orchestration-workers temporal-java helm/orchestration/temporal-worker -f helm/orchestration/temporal-java.values.yaml
          helm upgrade --install -n orchestration-workers temporal-python helm/orchestration/temporal-worker -f helm/orchestration/temporal-python.values.yaml
      - name: 'Run kubectl get pod -l app.kubernetes.io/component=frontend -n temporal -o json'
        shell: bash
        run: |
          kubectl get pod -l app.kubernetes.io/component=frontend -n temporal -o json
      - name: Wait for temporal startup
        shell: bash
        run: |
          kubectl -n temporal wait --for=condition=available --timeout=120s deployment/temporal-frontend
          kubectl -n temporal wait --for=jsonpath='{.status.conditions[?(@.type=="Ready")].status}' --timeout=60s pod -l app.kubernetes.io/component=frontend
          kubectl -n temporal wait --for=jsonpath='{.status.conditions[?(@.type=="ContainersReady")].status}' --timeout=60s pod -l app.kubernetes.io/component=frontend
          kubectl -n temporal wait --for=jsonpath='{.status.containerStatuses[?(@.name=="temporal-frontend")].state.running.startedAt}' --timeout=60s pod -l app.kubernetes.io/component=frontend
          kubectl -n temporal wait --for=jsonpath='{.status.initContainerStatuses[?(@.name=="check-elasticsearch-index")].state.terminated.reason}'=Completed --timeout=60s pod -l app.kubernetes.io/component=frontend
          kubectl -n temporal wait --for=condition=available --timeout=120s deployment/temporal-frontend
      - name: Launch temporal workflow
        shell: bash
        run: >
          kubectl exec -n temporal -i service/temporal-admintools -- temporal workflow start
          --task-queue ingest-hl7-log
          --type IngestHl7LogWorkflow
          --input '{"deltaLakePath":"<deltaLakePath>", "hl7OutputPath":"<hl7OutputPath>", "scratchSpaceRootPath":"<scratchSpaceRootPath>", "logsRootPath": "<logsRootPath>", "date":"<YYYYMMDD>"}' || kubectl get pod -l app.kubernetes.io/component=admintools -n temporal -o json